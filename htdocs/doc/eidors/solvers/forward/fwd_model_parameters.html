<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fwd_model_parameters</title>
  <meta name="keywords" content="fwd_model_parameters">
  <meta name="description" content="FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; fwd_model_parameters.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fwd_model_parameters
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function param = fwd_model_parameters( fwd_model, opt ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)
   Internal function to extract parameters from a fwd_model
   param.n_elem     =&gt; number of elements
   param.n_elec     =&gt; number of electrodes
   param.n_node     =&gt; number of nodes (vertices)
   param.n_stim     =&gt; number of current stimulation patterns
   param.n_elec     =&gt; number of electrodes
   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)
   param.n_meas     =&gt; number of measurements (total)
   param.boundary   =&gt; FEM boundary
   param.NODE       =&gt; vertex matrix
   param.ELEM       =&gt; connection matrix
   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)
   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)
   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)
   param.VOLUME     =&gt; Volume (or area) of each element
   param.normalize  =&gt; difference measurements normalized?
   param.N2E        =&gt; Node to electrode converter

 If the stimulation patterns has a 'interior_sources' field,
   the node current QQ, is set to this value for this stimulation.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>	FIND_ELECTRODE_BDY: find the boundary index area for electrode</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/deprecated/aa_fwd_parameters.html" class="code" title="function param = aa_fwd_parameters( fwd_model )">aa_fwd_parameters</a>	AA_FWD_PARAMETERS: data= aa_fwd_solve( fwd_model, image)</li><li><a href="../../../eidors/deprecated/exponential_covar_prior.html" class="code" title="function Reg= exponential_covar_prior( inv_model );">exponential_covar_prior</a>	EXPONENTIAL_COVAR_PRIOR image prior with exponential</li><li><a href="../../../eidors/examples/cheating_2d.html" class="code" title="function out=cheating_2d( figno, rand_seed )">cheating_2d</a>	code to simulate inverse crimes in EIT</li><li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../../eidors/graphics/matlab/show_fem_move.html" class="code" title="function [hf,hh] = show_fem_move( img, move, scale, options )">show_fem_move</a>	SHOW_FEM_MOVE   Plot EIT finite element model (FEM) and movement</li><li><a href="../../../eidors/graphics/matlab/show_slices_move.html" class="code" title="function show_slices_move( img, move, move_scale )">show_slices_move</a>	SHOW_SLICES_MOVE   Shows planar slices of a 3D FEM with movement vectors</li><li><a href="../../../eidors/solvers/calc_jacobian.html" class="code" title="function J = calc_jacobian( fwd_model, img)">calc_jacobian</a>	CALC_JACOBIAN: calculate jacobian from an inv_model</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="fwd_solve_2p5d_1st_order.html" class="code" title="function data =fwd_solve_2p5d_1st_order(fwd_model, img)">fwd_solve_2p5d_1st_order</a>	FWD_SOLVE_2P5D_1ST_ORDER: data= fwd_solve_2p5d_1st_order( img)</li><li><a href="fwd_solve_halfspace.html" class="code" title="function data = fwd_solve_halfspace(fwd_model, img)">fwd_solve_halfspace</a>	FWD_SOLVE_HALFSPACE: data = fwd_solve_halfspace(img)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_adjoint_2p5d_1st_order.html" class="code" title="function J= jacobian_adjoint_2p5d_1st_order( fwd_model, img)">jacobian_adjoint_2p5d_1st_order</a>	JACOBIAN_ADJOINT_2P5D: J= jacobian_adjoint_2p5d_1st_order( img )</li><li><a href="jacobian_movement.html" class="code" title="function J = jacobian_movement(fwd_model, img)">jacobian_movement</a>	JACOBIAN_MOVEMENT   Computes the Jacobian matrix for conductivity and</li><li><a href="jacobian_movement_2p5d_1st_order.html" class="code" title="function J = jacobian_movement_2p5d_1st_order( fwd_model, img)">jacobian_movement_2p5d_1st_order</a>	JACOBIAN_MOVEMENT_2P5D: J = jacobian_movement_2p5d_1st_order( img )</li><li><a href="jacobian_movement_halfspace.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_halfspace</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="jacobian_movement_perturb.html" class="code" title="function J= jacobian_movement_perturb( fwd_model, img)">jacobian_movement_perturb</a>	JACOBIAN_MOVEMENT_PERTURB: J= jacobian_movement_perturb( img )</li><li><a href="system_mat_2p5d_fields.html" class="code" title="function FT= system_mat_2p5d_fields( fwd_model )">system_mat_2p5d_fields</a>	SYSTEM_MAT_2P5D_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="system_mat_fields.html" class="code" title="function FC= system_mat_fields( fwd_model )">system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="update_system_mat_fields.html" class="code" title="function FC1 = update_system_mat_fields( fwd_model0, fwd_model1 )">update_system_mat_fields</a>	SYSTEM_MAT_FIELDS: fields (elem to nodes) fraction of system mat</li><li><a href="../../../eidors/solvers/inverse/inv_solve_backproj.html" class="code" title="function img= inv_solve_backproj( inv_model, data1, data2)">inv_solve_backproj</a>	INV_SOLVE_BACKPROJ inverse solver using backprojection</li><li><a href="../../../eidors/solvers/inverse/inv_solve_conj_grad.html" class="code" title="function img= inv_solve_conj_grad( inv_model, data1, data2)">inv_solve_conj_grad</a>	INV_SOLVE_CONJ_GRAD inverse solver based on the CG</li><li><a href="../../../eidors/solvers/inverse/inv_solve_core.html" class="code" title="function img= inv_solve_core( inv_model, data0, data1);">inv_solve_core</a>	INV_SOLVE_CORE Solver using a generic iterative algorithm</li><li><a href="../../../eidors/solvers/inverse/inv_solve_diff_kalman.html" class="code" title="function img= inv_solve_diff_kalman( inv_model, data1, data2)">inv_solve_diff_kalman</a>	INV_SOLVE_DIFF_KALMAN inverse solver for difference EIT</li><li><a href="../../../eidors/solvers/inverse/prior_exponential_covar.html" class="code" title="function Reg= prior_exponential_covar( inv_model );">prior_exponential_covar</a>	PRIOR_EXPONENTIAL_COVAR image prior with exponential</li><li><a href="../../../eidors/solvers/inverse/prior_laplace_old.html" class="code" title="function Reg= prior_laplace_old( inv_model );">prior_laplace_old</a>	PRIOR_LAPLACE calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_movement.html" class="code" title="function Reg= prior_movement( inv_model );">prior_movement</a>	PRIOR_MOVEMENT calculate image prior</li><li><a href="../../../eidors/solvers/inverse/prior_time_smooth.html" class="code" title="function Reg= prior_time_smooth( inv_model );">prior_time_smooth</a>	PRIOR_TIME_SMOOTH calculate image prior</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function pp= calc_param( fwd_model, opt )</a></li><li><a href="#_sub2" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a></li><li><a href="#_sub3" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a></li><li><a href="#_sub4" class="code">function [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes(</a></li><li><a href="#_sub5" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a></li><li><a href="#_sub6" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function param = fwd_model_parameters( fwd_model, opt )</a>
0002 <span class="comment">% FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</span>
0003 <span class="comment">%   Internal function to extract parameters from a fwd_model</span>
0004 <span class="comment">%   param.n_elem     =&gt; number of elements</span>
0005 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0006 <span class="comment">%   param.n_node     =&gt; number of nodes (vertices)</span>
0007 <span class="comment">%   param.n_stim     =&gt; number of current stimulation patterns</span>
0008 <span class="comment">%   param.n_elec     =&gt; number of electrodes</span>
0009 <span class="comment">%   param.n_dims     =&gt; dimentions (2= 2D, 3=3D)</span>
0010 <span class="comment">%   param.n_meas     =&gt; number of measurements (total)</span>
0011 <span class="comment">%   param.boundary   =&gt; FEM boundary</span>
0012 <span class="comment">%   param.NODE       =&gt; vertex matrix</span>
0013 <span class="comment">%   param.ELEM       =&gt; connection matrix</span>
0014 <span class="comment">%   param.QQ         =&gt; Current into each NODE (Neuman Boundary Conditions)</span>
0015 <span class="comment">%   param.VV         =&gt; Voltage driven into each NODE (Dirichlet BC - only where QQ is NaN)</span>
0016 <span class="comment">%   param.YY         =&gt; Output Admittance (1/Impedance) of each node current (for each value in QQ)</span>
0017 <span class="comment">%   param.VOLUME     =&gt; Volume (or area) of each element</span>
0018 <span class="comment">%   param.normalize  =&gt; difference measurements normalized?</span>
0019 <span class="comment">%   param.N2E        =&gt; Node to electrode converter</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% If the stimulation patterns has a 'interior_sources' field,</span>
0022 <span class="comment">%   the node current QQ, is set to this value for this stimulation.</span>
0023 
0024 <span class="comment">% (C) 2005 Andy Adler. License: GPL version 2 or version 3</span>
0025 <span class="comment">% $Id: fwd_model_parameters.m 5963 2019-06-05 10:33:21Z aadler $</span>
0026 
0027 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model, <span class="string">'UNIT_TEST'</span>); <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0028 
0029 <span class="keyword">if</span> nargin &lt; 2
0030    opt.skip_VOLUME = 0;
0031 <span class="keyword">else</span>
0032    assert(ischar(opt),<span class="string">'opt must be a string'</span>);
0033    assert(strcmp(opt,<span class="string">'skip_VOLUME'</span>),<span class="string">'opt can only be ''skip_VOLUME'''</span>);
0034    opt = struct;
0035    opt.skip_VOLUME = 1;
0036 <span class="keyword">end</span>
0037 
0038 copt.fstr = <span class="string">'fwd_model_parameters'</span>;
0039 copt.log_level = 4;
0040 
0041 param = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub1" class="code" title="subfunction pp= calc_param( fwd_model, opt )">calc_param</a>,{fwd_model, opt},copt);
0042 
0043 
0044 <span class="comment">% perform actual parameter calculation</span>
0045 <a name="_sub1" href="#_subfunctions" class="code">function pp= calc_param( fwd_model, opt )</a>
0046 
0047 pp.NODE= fwd_model.nodes';
0048 pp.ELEM= fwd_model.elems';
0049 
0050 n= size(pp.NODE,2);        <span class="comment">%NODEs</span>
0051 d= size(pp.ELEM,1);        <span class="comment">%dimentions+1</span>
0052 e= size(pp.ELEM,2);        <span class="comment">%ELEMents</span>
0053 <span class="keyword">try</span>
0054    p = length(fwd_model.stimulation );
0055 <span class="keyword">catch</span> 
0056    p = 0;
0057 <span class="keyword">end</span>
0058 <span class="keyword">try</span>
0059    n_elec= length( fwd_model.electrode );
0060 <span class="keyword">catch</span>
0061    n_elec= 0;
0062    fwd_model.electrode = [];
0063 <span class="keyword">end</span>
0064 
0065 <span class="keyword">if</span> ~opt.skip_VOLUME
0066    copt.fstr = <span class="string">'element_volume'</span>;
0067    copt.log_level = 4;
0068    pp.VOLUME= <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub2" class="code" title="subfunction VOLUME = element_volume( NODE, ELEM, e, d)">element_volume</a>, {pp.NODE, pp.ELEM, e, d}, copt );
0069 <span class="keyword">end</span>
0070 
0071 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'boundary'</span>)
0072     bdy = double( fwd_model.boundary ); <span class="comment">% double because of stupid matlab bugs</span>
0073 <span class="keyword">else</span>
0074     bdy = <a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(fwd_model.elems);
0075 <span class="keyword">end</span>
0076 <span class="keyword">try</span> <span class="comment">%add system_mat_fields.CEM_boundary if it exists</span>
0077    bdy = [bdy;fwd_model.system_mat_fields.CEM_boundary];
0078 <span class="keyword">end</span>
0079 
0080 <span class="comment">% Matrix to convert Nodes to Electrodes</span>
0081 <span class="comment">% Complete electrode model for all electrodes</span>
0082 <span class="comment">%  N2E = sparse(1:n_elec, n+ (1:n_elec), 1, n_elec, n+n_elec);</span>
0083 <span class="comment">%  pp.QQ= sparse(n+n_elec,p);</span>
0084 copt.cache_obj = {fwd_model.nodes,fwd_model.elems,fwd_model.electrode};
0085 copt.fstr = <span class="string">'calculate_N2E'</span>;
0086 [N2E,cem_electrodes] = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub3" class="code" title="subfunction [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);">calculate_N2E</a>,{fwd_model, bdy, n_elec, n}, copt);
0087 
0088 <span class="keyword">if</span> p&gt;0
0089   stim = fwd_model.stimulation;
0090   [pp.QQ, pp.VV, pp.n_meas] = <a href="#_sub6" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(N2E, stim, p);
0091 <span class="keyword">end</span>
0092 
0093 <span class="comment">% pack into a parameter return list</span>
0094 pp.n_elem   = e;
0095 pp.n_elec   = n_elec;
0096 pp.n_node   = n;
0097 pp.n_stim   = p;
0098 pp.n_dims   = d-1;
0099 pp.N2E      = N2E;
0100 pp.boundary = bdy;
0101 pp.normalize = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(fwd_model);
0102 
0103 
0104 <span class="comment">% calculate element volume and surface area</span>
0105 <a name="_sub2" href="#_subfunctions" class="code">function VOLUME = element_volume( NODE, ELEM, e, d)</a>
0106    VOLUME=zeros(e,1);
0107    ones_d = ones(1,d);
0108    d1fac = prod( 1:d-1 );
0109    <span class="keyword">if</span> d &gt; size(NODE,1)
0110       <span class="keyword">for</span> i=1:e
0111           this_elem = NODE(:,ELEM(:,i)); 
0112           VOLUME(i)= abs(det([ones_d;this_elem])) / d1fac;
0113       <span class="keyword">end</span>
0114    <span class="keyword">elseif</span> d == 3 <span class="comment">% 3D nodes in 2D mesh</span>
0115       <span class="keyword">for</span> i=1:e
0116           this_elem = NODE(:,ELEM(:,i)); 
0117           d12= det([ones_d;this_elem([1,2],:)])^2;
0118           d13= det([ones_d;this_elem([1,3],:)])^2;
0119           d23= det([ones_d;this_elem([2,3],:)])^2;
0120           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0121       <span class="keyword">end</span>
0122    <span class="keyword">elseif</span> d == 2 <span class="comment">% 3D nodes in 1D mesh (ie resistor mesh)</span>
0123       <span class="keyword">for</span> i=1:e
0124           this_elem = NODE(:,ELEM(:,i)); 
0125           d12= det([ones_d;this_elem([1],:)])^2;
0126           d13= det([ones_d;this_elem([2],:)])^2;
0127           d23= det([ones_d;this_elem([3],:)])^2;
0128           VOLUME(i)= sqrt(d12 + d13 + d23 ) / d1fac;
0129       <span class="keyword">end</span>
0130    <span class="keyword">else</span>
0131       warning(<span class="string">'mesh size not understood when calculating volumes'</span>)
0132       VOLUME = NaN;
0133    <span class="keyword">end</span>
0134 
0135 
0136 <a name="_sub3" href="#_subfunctions" class="code">function [N2E,cem_electrodes] = calculate_N2E( fwd_model, bdy, n_elec, n);</a>
0137    cem_electrodes= 0; <span class="comment">% num electrodes part of Compl. Elec Model</span>
0138    N2E = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec, n+n_elec);
0139    <span class="keyword">for</span> i=1:n_elec
0140       eleci = fwd_model.electrode(i);
0141 <span class="comment">% The faces field is used only if</span>
0142       <span class="keyword">if</span> isfield(eleci,<span class="string">'faces'</span>)  &amp;&amp; ~isempty(eleci.faces)
0143         <span class="keyword">if</span> ~isempty(eleci.nodes)
0144            <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: electrode %d has both faces and nodes'</span>,i);
0145         <span class="keyword">end</span>
0146         <span class="comment">% This is a CEM electrode</span>
0147         cem_electrodes = cem_electrodes+1;
0148         N2Ei= 1;
0149         N2Ei_nodes = n+cem_electrodes;
0150 
0151       <span class="keyword">elseif</span> isfield(eleci,<span class="string">'nodes'</span>) 
0152           elec_nodes = fwd_model.electrode(i).nodes;
0153          [N2Ei,N2Ei_nodes,cem_electrodes] =  <span class="keyword">...</span>
0154              <a href="#_sub4" class="code" title="subfunction [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes( ">N2Ei_from_nodes</a>(fwd_model, <span class="keyword">...</span>
0155               bdy, elec_nodes, cem_electrodes,n);
0156       <span class="keyword">else</span>
0157           <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: electrode %d has no nodes'</span>,i);
0158           <span class="keyword">break</span>; <span class="comment">%Not a real electrode so don't include</span>
0159       <span class="keyword">end</span>
0160       N2E(i, N2Ei_nodes) = N2Ei;
0161    <span class="keyword">end</span>
0162    N2E = N2E(:, 1:(n+cem_electrodes));
0163 
0164 <span class="comment">% If N2E can be made a logical (0-1) matrix, do it.</span>
0165    <span class="keyword">if</span> all(N2E(find(N2E(:)))==1)
0166       N2E = logical(N2E);
0167    <span class="keyword">end</span>
0168 
0169 
0170 <a name="_sub4" href="#_subfunctions" class="code">function [N2Ei,N2Ei_nodes,cem_electrodes]= N2Ei_from_nodes( </a><span class="keyword">...</span>
0171       fwd_model, bdy, elec_nodes, cem_electrodes,n);
0172   <span class="keyword">if</span> length(elec_nodes) ==1 <span class="comment">% point electrode (maybe inside body)</span>
0173      N2Ei = 1;
0174      N2Ei_nodes = elec_nodes;
0175   <span class="keyword">elseif</span> length(elec_nodes) ==0
0176     error(<span class="string">'EIDORS:fwd_model_parameters:electrode'</span>,<span class="string">'zero length electrode specified'</span>);
0177   <span class="keyword">else</span>
0178      bdy_idx= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, [], elec_nodes);
0179 
0180      <span class="keyword">if</span> ~isempty(bdy_idx) <span class="comment">% CEM electrode</span>
0181         cem_electrodes = cem_electrodes+1;
0182         N2Ei= 1;
0183         N2Ei_nodes = n+cem_electrodes;
0184      <span class="keyword">else</span> <span class="comment">% a set of point electrodes</span>
0185           <span class="comment">% FIXME: make current defs between point electrodes and CEMs compatible</span>
0186         [bdy_idx,srf_area]= <a href="find_electrode_bdy.html" class="code" title="function [bdy_idx, bdy_area] = find_electrode_bdy( bdy, vtx, elec_nodes)">find_electrode_bdy</a>( bdy, <span class="keyword">...</span>
0187                        fwd_model.nodes, elec_nodes);
0188         s_srf_area =  sum(srf_area);
0189         <span class="keyword">if</span> s_srf_area == 0;
0190            error(<span class="string">'Surface area for elec#%d is zero. Is boundary correct?'</span>,i);
0191         <span class="keyword">end</span>
0192         N2Ei = srf_area/s_srf_area;
0193         N2Ei_nodes= elec_nodes;
0194      <span class="keyword">end</span>
0195   <span class="keyword">end</span>
0196 
0197 
0198 <a name="_sub5" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)</a>
0199    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0200    VV = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p); N2E0 = N2E&gt;0;
0201    n_meas= 0; <span class="comment">% sum total number of measurements</span>
0202    <span class="keyword">for</span> i=1:p
0203        src= zeros(size(N2E,2),1);
0204        <span class="keyword">try</span>;  src =       N2E' * stim(i).stim_pattern; <span class="keyword">end</span>
0205        <span class="keyword">try</span>;  src = src + stim(i).interior_sources;    <span class="keyword">end</span>
0206        <span class="keyword">if</span> all(size(src) == [1,1]) &amp;&amp; src==0
0207           error(<span class="string">'no stim_patterns or interior_sources provided for pattern #%d'</span>,i);
0208        <span class="keyword">end</span>
0209        
0210        QQ(:,i) = src;
0211        n_meas = n_meas + size(stim(i).meas_pattern,1);
0212 
0213        vlt= zeros(size(N2E,2),1);
0214        <span class="keyword">try</span>;  vlt =      N2E0' * stim(i).volt_pattern; <span class="keyword">end</span>
0215        VV(:,i) = vlt;
0216    <span class="keyword">end</span>
0217 
0218 <a name="_sub6" href="#_subfunctions" class="code">function [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)</a>
0219    <span class="keyword">try</span>
0220    ncols = arrayfun(@(x) size(x.stim_pattern,2), stim);
0221    <span class="keyword">end</span>
0222    <span class="keyword">if</span> any(ncols&gt;1);
0223       str = <span class="string">'multiple columns in stim_pattern for patterns: '</span>;
0224       error(<span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>, <span class="keyword">...</span>
0225             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0226    <span class="keyword">end</span>
0227    idx = 1:p; idx(ncols==0)= [];
0228 
0229    QQ = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0230    <span class="keyword">try</span>
0231    QQ(:,idx) = N2E' * horzcat( stim(:).stim_pattern );
0232    <span class="keyword">end</span>
0233    VV = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(N2E,2),p);
0234    <span class="comment">% For voltages, we just need to know which N2E, not the size</span>
0235 
0236 
0237 
0238    <span class="keyword">try</span>
0239    ncols = arrayfun(@(x) size(x.volt_pattern,2), stim);
0240    <span class="keyword">end</span>
0241    <span class="keyword">if</span> any(ncols&gt;1);
0242       str = <span class="string">'multiple columns in volt_pattern for patterns: '</span>;
0243       error(<span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>, <span class="keyword">...</span>
0244             [str, sprintf(<span class="string">'#%d '</span>,find(ncols&gt;1))]);
0245    <span class="keyword">end</span>
0246    idx = 1:p; idx(ncols==0)= [];
0247 
0248    <span class="keyword">try</span>
0249    VV(:,idx) = (N2E&gt;0)' * horzcat( stim(:).volt_pattern );
0250    <span class="keyword">end</span>
0251 
0252    n_meas = size(vertcat(stim(:).meas_pattern),1);
0253 
0254 
0255 
0256 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0257    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,16); fmdl = imdl.fwd_model;
0258    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0259    [QQ1, VV1, n1m] = <a href="#_sub5" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_slow(N2E, stim, p)">calc_QQ_slow</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0260    [QQ2, VV2, n2m] = <a href="#_sub6" class="code" title="subfunction [QQ, VV, n_meas] = calc_QQ_fast(N2E, stim, p)">calc_QQ_fast</a>(pp.N2E, fmdl.stimulation, pp.n_stim);
0261    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_QQ'</span>, norm(QQ1-QQ2,<span class="string">'fro'</span>) + norm(n1m-n2m), 0, 1e-15);
0262    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV1'</span>, norm(VV1,<span class="string">'fro'</span>), 0, 1e-15);
0263    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'calc_VV2'</span>, norm(VV2,<span class="string">'fro'</span>), 0, 1e-15);
0264 
0265    <span class="keyword">for</span> i=1:6;
0266       imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2C0'</span>,4); fmdl = imdl.fwd_model;
0267       <span class="keyword">switch</span> i
0268          <span class="keyword">case</span> 1; fmdl.stimulation(3).stim_pattern = fmdl.stimulation(3).stim_pattern*[1,2]; 
0269                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:stim_pattern'</span>;
0270          <span class="keyword">case</span> 2; fmdl.stimulation(1).stim_pattern = [];
0271                  expected_err = <span class="string">''</span>; expected = zeros(45,4);
0272                  expected(42:45,2:4) = [0,0,1;-1,0,0;1,-1,0;0,1,-1]*10;
0273                  param = <span class="string">'QQ'</span>;
0274          <span class="keyword">case</span> 3; fmdl.electrode(1).nodes = [];
0275                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:electrode'</span>;
0276          <span class="keyword">case</span> 4; fmdl.stimulation(1).volt_pattern = [zeros(3,1);6];
0277                  expected_err = <span class="string">''</span>; expected = zeros(45,4); expected(45,1) = 6;
0278                  param = <span class="string">'VV'</span>;
0279          <span class="keyword">case</span> 5; fmdl.stimulation(3).volt_pattern = [ones(4,2)];
0280                  expected_err = <span class="string">'EIDORS:fwd_model_parameters:volt_pattern'</span>;
0281          <span class="keyword">case</span> 6; fmdl.electrode(3).faces = [1,2;2,3;3,1];
0282                  fmdl.electrode(3).nodes = [];
0283                  expected_err = <span class="string">''</span>; expected = zeros(4,45);
0284                  expected(:,42:45) = eye(4);
0285                  param = <span class="string">'N2E'</span>;
0286       <span class="keyword">end</span>
0287       err= <span class="string">''</span>;
0288       <span class="keyword">try</span>;  pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>(fmdl);
0289       <span class="keyword">catch</span> e
0290          err= e.identifier;
0291       <span class="keyword">end</span>
0292       <span class="keyword">if</span> length(expected_err)&gt;0;
0293          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'expected error:'</span>,num2str(i)], err, expected_err);
0294       <span class="keyword">else</span>
0295          <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>([<span class="string">'case:'</span>,num2str(i)], full(pp.(param)), expected);
0296       <span class="keyword">end</span>
0297    <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 31-Dec-2019 17:38:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>