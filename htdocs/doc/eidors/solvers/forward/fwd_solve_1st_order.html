<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fwd_solve_1st_order</title>
  <meta name="keywords" content="fwd_solve_1st_order">
  <meta name="description" content="FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="../index.html">solvers</a> &gt; <a href="index.html">forward</a> &gt; fwd_solve_1st_order.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/solvers/forward&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>fwd_solve_1st_order
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function data =fwd_solve_1st_order(fwd_model, img) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)
 First order FEM forward solver
 Input:
    img       = image struct
 Output:
    data = measurements struct
 Options: (to return internal FEM information)
    img.fwd_solve.get_all_meas = 1 (data.volt = all FEM nodes, but not CEM)
    img.fwd_solve.get_all_nodes= 1 (data.volt = all nodes, including CEM)
    img.fwd_solve.get_elec_curr= 1 (data.elec_curr = current on electrodes)

 Model Reduction: use precomputed fields to reduce the size of
    the forward solution. Nodes which are 1) not used in the output
    (i.e. not electrodes) 2) all connected to the same conductivity via
    the c2f mapping are applicable.
 see: Model Reduction for FEM Forward Solutions, Adler &amp; Lionheart, EIT2016

    img.fwd_model.model_reduction = @calc_model_reduction;
       where the functionputs a struct with fields: main_region, regions
       OR
    img.fwd_model.model_reduction.main_region = vector, and 
    img.fwd_model.model_reduction.regions = struct</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>	EIDORS_OBJ: maintains EIDORS internals</li><li><a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>	SHOW_FEM: show the EIDORS3D finite element model</li><li><a href="../../../eidors/models/convert_img_units.html" class="code" title="function y = convert_img_units(img,arg1,arg2)">convert_img_units</a>	CONVERT_IMG_UNITS change image data units</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>	MDL_NORMALIZE Check or set the normalize_measurements flag on a model.</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>	MK_GRID_MODEL: Create reconstruction model on pixelated grid</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>	NUM_NODES: number of elemnts in a (fwd or inv model or image)</li><li><a href="../../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>	STIM_MEAS_LIST: mk stimulation pattern from list of electrodes</li><li><a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>	</li><li><a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>	SPARSE Create sparse matrix (EIDORS overload).</li><li><a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>	CALC_SYSTEM_MAT: calculate FEM system matrix from fwd_model and image</li><li><a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>	[srf, idx] = find_boundary(simp);</li><li><a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>	FWD_MODEL_PARAMETERS: data= fwd_solve_1st_order( fwd_model, image)</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../../eidors/tests/test_2d_resistor.html" class="code" title="function test_2d_resistor(opt)">test_2d_resistor</a>	Create 2D model of a cylindrical resistor</li><li><a href="../../../eidors/tests/test_3d_resistor.html" class="code" title="">test_3d_resistor</a>	Create 3D model of a Rectangular resistor</li><li><a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>	EIDORS_CACHE Control eidors caching</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>	[V] = LEFT_DIVIDE(E,I,tol,pp,V);</li><li><a href="../../../eidors/deprecated/aa_fwd_solve.html" class="code" title="function data =aa_fwd_solve(varargin)">aa_fwd_solve</a>	AA_FWD_SOLVE: data= aa_fwd_solve( fwd_model, img)</li><li><a href="../../../eidors/deprecated/np_fwd_solve.html" class="code" title="function data= np_fwd_solve( fwd_model, img)">np_fwd_solve</a>	NP_FWD_SOLVE: data= np_fwd_solve( fwd_model, img)</li><li><a href="../../../eidors/examples/demo_3d_simdata.html" class="code" title="">demo_3d_simdata</a>	How to make simulation data using EIDORS3D</li><li><a href="../../../eidors/examples/eidors2d_demo1.html" class="code" title="">eidors2d_demo1</a>	EidorsDemo1 Demonstrates the use of 2D EIT Package with linear basis</li><li><a href="../../../eidors/graphics/matlab/show_current.html" class="code" title="function quiv = show_current( img, vv )">show_current</a>	SHOW_CURRENT: show current or other quantity defined</li><li><a href="../../../eidors/models/calc_elem_current.html" class="code" title="function elemcur = calc_elem_current( img, vv )">calc_elem_current</a>	calc_elem_current: calculate current vector in each FEM element</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>	FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</li><li><a href="jacobian_adjoint.html" class="code" title="function J= jacobian_adjoint( fwd_model, img)">jacobian_adjoint</a>	JACOBIAN_ADJOINT: J= jacobian_adjoint( img )</li><li><a href="jacobian_perturb.html" class="code" title="function J= jacobian_perturb( fwd_model, img)">jacobian_perturb</a>	JACOBIAN_PERTURB: J= jacobian_perturb( fwd_model, img)</li><li><a href="system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>	SYSTEM_MAT_1ST_ORDER: SS= system_mat_1st_order( fwd_model, img)</li><li><a href="../../../eidors/tests/perturb_jacobian_test.html" class="code" title="">perturb_jacobian_test</a>	Perturbation Jacobians</li><li><a href="../../../eidors/tests/test_2d_resistor.html" class="code" title="function test_2d_resistor(opt)">test_2d_resistor</a>	Create 2D model of a cylindrical resistor</li><li><a href="../../../eidors/tests/test_3d_resistor.html" class="code" title="">test_3d_resistor</a>	Create 3D model of a Rectangular resistor</li><li><a href="../../../eidors/tests/test_c2f_jacobian.html" class="code" title="function test_c2f_jacobian">test_c2f_jacobian</a>	Test calc of jacobian given coarse to fine mapping</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [dirichlet_nodes, dirichlet_values, neumann_nodes, has_gnd_node]=</a></li><li><a href="#_sub2" class="code">function pp = set_gnd_node(fwd_model, pp);</a></li><li><a href="#_sub3" class="code">function vv = meas_from_v_els( v_els, stim)</a></li><li><a href="#_sub4" class="code">function v2meas = get_v2meas(n_elec,n_stim,stim)</a></li><li><a href="#_sub5" class="code">function [E, m_idx, pp] = mdl_reduction(E, mr, img, pp);</a></li><li><a href="#_sub6" class="code">function unit_test_voltage_stims;</a></li><li><a href="#_sub7" class="code">function do_unit_test</a></li><li><a href="#_sub8" class="code">function [R,img] = test_2d_resistor(current,measure)</a></li><li><a href="#_sub9" class="code">function [R,img] = test_2d_resistor_faces(current,measure)</a></li><li><a href="#_sub10" class="code">function [R,img] = test_3d_resistor(current,measure);;</a></li><li><a href="#_sub11" class="code">function [R,img] = test_3d_resistor_faces(current,measure);;</a></li><li><a href="#_sub12" class="code">function [R,img] = test_3d_resistor_old(current,measure);</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data =fwd_solve_1st_order(fwd_model, img)</a>
0002 <span class="comment">% FWD_SOLVE_1ST_ORDER: data= fwd_solve_1st_order( img)</span>
0003 <span class="comment">% First order FEM forward solver</span>
0004 <span class="comment">% Input:</span>
0005 <span class="comment">%    img       = image struct</span>
0006 <span class="comment">% Output:</span>
0007 <span class="comment">%    data = measurements struct</span>
0008 <span class="comment">% Options: (to return internal FEM information)</span>
0009 <span class="comment">%    img.fwd_solve.get_all_meas = 1 (data.volt = all FEM nodes, but not CEM)</span>
0010 <span class="comment">%    img.fwd_solve.get_all_nodes= 1 (data.volt = all nodes, including CEM)</span>
0011 <span class="comment">%    img.fwd_solve.get_elec_curr= 1 (data.elec_curr = current on electrodes)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Model Reduction: use precomputed fields to reduce the size of</span>
0014 <span class="comment">%    the forward solution. Nodes which are 1) not used in the output</span>
0015 <span class="comment">%    (i.e. not electrodes) 2) all connected to the same conductivity via</span>
0016 <span class="comment">%    the c2f mapping are applicable.</span>
0017 <span class="comment">% see: Model Reduction for FEM Forward Solutions, Adler &amp; Lionheart, EIT2016</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%    img.fwd_model.model_reduction = @calc_model_reduction;</span>
0020 <span class="comment">%       where the functionputs a struct with fields: main_region, regions</span>
0021 <span class="comment">%       OR</span>
0022 <span class="comment">%    img.fwd_model.model_reduction.main_region = vector, and</span>
0023 <span class="comment">%    img.fwd_model.model_reduction.regions = struct</span>
0024 
0025 <span class="comment">% (C) 1995-2017 Andy Adler. License: GPL version 2 or version 3</span>
0026 <span class="comment">% $Id: fwd_solve_1st_order.m 6005 2019-06-29 13:26:42Z aadler $</span>
0027 
0028 <span class="comment">% correct input paralemeters if function was called with only img</span>
0029 <span class="keyword">if</span> ischar(fwd_model) &amp;&amp; strcmp(fwd_model,<span class="string">'UNIT_TEST'</span>); <a href="#_sub7" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0030 
0031 <span class="keyword">if</span> nargin == 1
0032    img= fwd_model;
0033 <span class="keyword">elseif</span>  strcmp(getfield(warning(<span class="string">'query'</span>,<span class="string">'EIDORS:DeprecatedInterface'</span>),<span class="string">'state'</span>),<span class="string">'on'</span>)
0034    warning(<span class="string">'EIDORS:DeprecatedInterface'</span>, <span class="keyword">...</span>
0035       [<span class="string">'Calling FWD_SOLVE_1ST_ORDER with two arguments is deprecated and will cause'</span> <span class="keyword">...</span>
0036        <span class="string">' an error in a future version. First argument ignored.'</span>]);
0037 <span class="keyword">end</span>
0038 fwd_model= img.fwd_model;
0039 
0040 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img);
0041 <span class="keyword">if</span> ~ismember(img.current_params, <a href="../../../eidors/models/supported_params.html" class="code" title="function list = supported_params">supported_params</a>)
0042     error(<span class="string">'EIDORS:PhysicsNotSupported'</span>, <span class="string">'%s does not support %s'</span>, <span class="keyword">...</span>
0043     <span class="string">'FWD_SOLVE_1ST_ORDER'</span>,img.current_params);
0044 <span class="keyword">end</span>
0045 <span class="comment">% all calcs use conductivity</span>
0046 img = <a href="../../../eidors/models/convert_img_units.html" class="code" title="function y = convert_img_units(img,arg1,arg2)">convert_img_units</a>(img, <span class="string">'conductivity'</span>);
0047 
0048 pp= <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( fwd_model, <span class="string">'skip_VOLUME'</span> );
0049 pp = <a href="#_sub2" class="code" title="subfunction pp = set_gnd_node(fwd_model, pp);">set_gnd_node</a>(fwd_model, pp);
0050 s_mat= <a href="../../../eidors/solvers/calc_system_mat.html" class="code" title="function system_mat = calc_system_mat( fwd_model, img)">calc_system_mat</a>( img );
0051 
0052 <span class="keyword">if</span> isfield(fwd_model,<span class="string">'model_reduction'</span>)
0053    [s_mat.E, main_idx, pp] = <a href="#_sub5" class="code" title="subfunction [E, m_idx, pp] = mdl_reduction(E, mr, img, pp);">mdl_reduction</a>(s_mat.E, <span class="keyword">...</span>
0054            img.fwd_model.model_reduction, img, pp );
0055 <span class="keyword">else</span>
0056    pp.mr_mapper = 1:size(s_mat.E,1);
0057 <span class="keyword">end</span>
0058 
0059 <span class="comment">% Normally EIT uses current stimulation. In this case there is</span>
0060 <span class="comment">%  only a ground node, and this is the only dirichlet_nodes value.</span>
0061 <span class="comment">%  In that case length(dirichlet_nodes) is 1 and the loop runs once</span>
0062 <span class="comment">% If voltage stimulation is done, then we need to loop on the</span>
0063 <span class="comment">%  matrix to calculate faster.</span>
0064 [dirichlet_nodes, dirichlet_values, neumann_nodes, has_gnd_node]= <span class="keyword">...</span>
0065          find_dirichlet_nodes( fwd_model, pp );
0066 
0067 v= full(horzcat(dirichlet_values{:})); <span class="comment">% Pre fill in matrix</span>
0068 <span class="keyword">for</span> i=1:length(dirichlet_nodes)
0069    idx= 1:size(s_mat.E,1);
0070    idx( dirichlet_nodes{i} ) = [];
0071    <span class="comment">% If all dirichlet patterns are the same, then calc in one go</span>
0072    <span class="keyword">if</span> length(dirichlet_nodes) == 1; rhs = 1:size(pp.QQ,2);
0073    <span class="keyword">else</span>                           ; rhs = i; <span class="keyword">end</span>
0074    v(idx,rhs)= <a href="../../../eidors/algorithms/left_divide.html" class="code" title="function [V] = left_divide(E,I,tol,~,V)">left_divide</a>( s_mat.E(idx,idx), <span class="keyword">...</span>
0075              neumann_nodes{i}(idx,:) - s_mat.E(idx,:)*dirichlet_values{i});
0076 <span class="keyword">end</span>
0077 
0078 <span class="comment">% If model has a ground node, check if current flowing in this node</span>
0079 <span class="keyword">if</span> has_gnd_node
0080    Ignd = s_mat.E(dirichlet_nodes{1},:)*v;
0081    Irel = Ignd./sum(abs(pp.QQ)); <span class="comment">% relative</span>
0082    <span class="keyword">if</span> max(abs(Irel))&gt;1e-6
0083       warning(<span class="string">'current flowing through ground node. Check stimulation pattern'</span>)
0084    <span class="keyword">end</span>
0085 <span class="keyword">end</span>
0086 
0087 <span class="comment">% calc voltage on electrodes</span>
0088 
0089 <span class="comment">% This is horribly inefficient, override</span>
0090 <span class="comment">% v_els= pp.N2E * v;</span>
0091 idx = find(any(pp.N2E));
0092 v_els= pp.N2E(:,idx) * v(idx,:);
0093 
0094 
0095 <span class="comment">% create a data structure to return</span>
0096 data.meas= <a href="#_sub3" class="code" title="subfunction vv = meas_from_v_els( v_els, stim)">meas_from_v_els</a>(v_els, fwd_model.stimulation);
0097 data.time= NaN; <span class="comment">% unknown</span>
0098 data.name= <span class="string">'solved by fwd_solve_1st_order'</span>;
0099 <span class="keyword">try</span>; <span class="keyword">if</span> img.fwd_solve.get_all_meas == 1
0100    outmap = pp.mr_mapper(1:pp.n_node);
0101    data.volt(outmap,:) = v(1:pp.n_node,:); <span class="comment">% but not on CEM nodes</span>
0102 <span class="keyword">end</span>; <span class="keyword">end</span>
0103 <span class="keyword">try</span>; <span class="keyword">if</span> img.fwd_solve.get_all_nodes== 1
0104    data.volt(pp.mr_mapper,:) = v;                <span class="comment">% all, including CEM nodes</span>
0105 <span class="keyword">end</span>; <span class="keyword">end</span>
0106 <span class="keyword">try</span>; <span class="keyword">if</span> img.fwd_solve.get_elec_curr== 1
0107 <span class="comment">%  data.elec_curr = pp.N2E * s_mat.E * v;</span>
0108    idx = find(any(pp.N2E));
0109    data.elec_curr = pp.N2E(:,idx) * s_mat.E(idx,:) * v;
0110 <span class="keyword">end</span>; <span class="keyword">end</span>
0111 
0112 
0113 <span class="comment">% has_gnd_node = flag if the model has a gnd_node =&gt; can warn if current flows</span>
0114 <a name="_sub1" href="#_subfunctions" class="code">function [dirichlet_nodes, dirichlet_values, neumann_nodes, has_gnd_node]= </a><span class="keyword">...</span>
0115             find_dirichlet_nodes( fwd_model, pp );
0116    fnanQQ = isnan(pp.QQ);
0117    lstims = size(pp.QQ,2);
0118    <span class="comment">% Can't use any(...) because if does implicit all</span>
0119    <span class="keyword">if</span> any(any(fnanQQ))
0120       has_gnd_node = 0; <span class="comment">% no ground node is specified</span>
0121       <span class="comment">% Are all dirichlet_nodes the same</span>
0122 
0123       <span class="comment">% Don't use all on sparse, it will make them full</span>
0124       <span class="comment">% Check if all rows are the same</span>
0125       <span class="keyword">if</span> ~any(any(fnanQQ(:,1)*ones(1,lstims) - fnanQQ,2))
0126          dirichlet_nodes{1} = find(fnanQQ(:,1));
0127          dirichlet_values{1} = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(pp.N2E,2), size(fnanQQ,2));
0128          dirichlet_values{1}(fnanQQ) = pp.VV(fnanQQ);
0129          neumann_nodes{1} = pp.QQ;
0130          neumann_nodes{1}(fnanQQ) = 0;
0131       <span class="keyword">else</span> <span class="comment">% one at a time</span>
0132          <span class="keyword">for</span> i=1:size(fnanQQ,2)
0133             fnanQQi= fnanQQ(:,i);
0134             <span class="keyword">if</span> any(fnanQQi)
0135                dirichlet_nodes{i} = find(fnanQQi);
0136                dirichlet_values{i} = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(pp.N2E,2), 1);
0137                dirichlet_values{i}(fnanQQi) = pp.VV(fnanQQi,i);
0138                neumann_nodes{i} = pp.QQ(:,i);
0139                neumann_nodes{i}(fnanQQi) = 0;
0140             <span class="keyword">elseif</span> isfield(pp,<span class="string">'gnd_node'</span>)
0141                dirichlet_nodes{i} = pp.gnd_node;
0142                dirichlet_values{i} = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(pp.N2E,2), 1);
0143                neumann_nodes{1}   = pp.QQ(:,i);
0144                has_gnd_node= 1;
0145             <span class="keyword">else</span>
0146                error(<span class="string">'no required ground node on model'</span>);
0147             <span class="keyword">end</span>
0148          <span class="keyword">end</span>
0149       <span class="keyword">end</span>
0150    <span class="keyword">elseif</span> isfield(pp,<span class="string">'gnd_node'</span>)
0151       dirichlet_nodes{1} = pp.gnd_node;
0152       dirichlet_values{1} = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(size(pp.N2E,2), size(fnanQQ,2));
0153       neumann_nodes{1}   = pp.QQ;
0154       has_gnd_node= 1;
0155    <span class="keyword">else</span>
0156       error(<span class="string">'no required ground node on model'</span>);
0157    <span class="keyword">end</span>
0158 
0159 <a name="_sub2" href="#_subfunctions" class="code">function pp = set_gnd_node(fwd_model, pp);</a>
0160    <span class="keyword">if</span> isfield(fwd_model,<span class="string">'gnd_node'</span>);
0161       pp.gnd_node = fwd_model.gnd_node;
0162    <span class="keyword">else</span>
0163       <span class="comment">% try to find one in the model center</span>
0164       ctr =  mean(fwd_model.nodes,1);
0165       d2  =  sum(bsxfun(@minus,fwd_model.nodes,ctr).^2,2);
0166       [~,pp.gnd_node] = min(d2);
0167       <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'Warning: no ground node found: choosing node %d'</span>,pp.gnd_node(1),1);
0168    <span class="keyword">end</span>
0169 
0170 <a name="_sub3" href="#_subfunctions" class="code">function vv = meas_from_v_els( v_els, stim)</a>
0171    <span class="keyword">try</span>
0172 <span class="comment">% Was 1.82s</span>
0173 <span class="comment">%        % measured voltages from v</span>
0174 <span class="comment">%    %   vv = zeros( pp.n_meas, 1 );</span>
0175 <span class="comment">%        idx=0;</span>
0176 <span class="comment">%        for i=1:length(stim)</span>
0177 <span class="comment">%           meas_pat= stim(i).meas_pattern;</span>
0178 <span class="comment">%           n_meas  = size(meas_pat,1);</span>
0179 <span class="comment">%           vv( idx+(1:n_meas) ) = meas_pat*v_els(:,i);</span>
0180 <span class="comment">%           idx= idx+ n_meas;</span>
0181 <span class="comment">%        end</span>
0182 
0183 <span class="comment">% This code replaced the previous - Nov 4, 2013</span>
0184 <span class="comment">% Now 0.437s</span>
0185 <span class="comment">% Why is it faster??</span>
0186 
0187        [n_elec,n_stim] = size(v_els);
0188 
0189        copt.cache_obj = {stim};
0190        copt.fstr = <span class="string">'v2meas'</span>;
0191        copt.log_level = 4;
0192        v2meas = <a href="../../../eidors/tools/eidors_cache.html" class="code" title="function varargout=eidors_cache( command, varargin )">eidors_cache</a>(@<a href="#_sub4" class="code" title="subfunction v2meas = get_v2meas(n_elec,n_stim,stim)">get_v2meas</a>, {n_elec,n_stim,stim}, copt);
0193        vv = v2meas' * v_els(:);
0194    <span class="keyword">catch</span> err
0195       <span class="keyword">if</span> strcmp(err.identifier, <span class="string">'MATLAB:innerdim'</span>);
0196           error([<span class="string">'measurement pattern not compatible with number'</span> <span class="keyword">...</span>
0197                   <span class="string">'of electrodes for stimulation patter %d'</span>],i);
0198       <span class="keyword">else</span>
0199           rethrow(err);
0200       <span class="keyword">end</span>
0201    <span class="keyword">end</span>
0202 
0203    
0204 <a name="_sub4" href="#_subfunctions" class="code">function v2meas = get_v2meas(n_elec,n_stim,stim)</a>
0205     v2meas = <a href="../../../eidors/overloads/sparse.html" class="code" title="function S = sparse(varargin)">sparse</a>(n_elec*n_stim,0);
0206     <span class="keyword">for</span> i=1:n_stim
0207         meas_pat= stim(i).meas_pattern;
0208         n_meas  = size(meas_pat,1);
0209         v2meas((i-1)*n_elec + 1: i*n_elec,end+(1:n_meas)) = meas_pat';
0210     <span class="keyword">end</span>
0211 
0212 
0213 <a name="_sub5" href="#_subfunctions" class="code">function [E, m_idx, pp] = mdl_reduction(E, mr, img, pp);</a>
0214    <span class="comment">% if mr is a string we assume it's a function name</span>
0215    <span class="keyword">if</span> isa(mr,<span class="string">'function_handle'</span>) || ischar(mr)
0216       mr = feval(mr,img.fwd_model);
0217    <span class="keyword">end</span>
0218    <span class="comment">% mr is now a struct with fields: main_region, regions</span>
0219    m_idx = mr.main_region;
0220    E = E(m_idx, m_idx);
0221    <span class="keyword">for</span> i=1:length(mr.regions)
0222       invEi=   mr.regions(i).invE;
0223 <span class="comment">% FIXME:!!! data_mapper has done the c2f. But we don't want that here.</span>
0224 <span class="comment">%  kludge is to reach into the fine model field. This is only ok because</span>
0225 <span class="comment">%  model_reduction is only valid if one parameter describes each field</span>
0226       field = mr.regions(i).field; 
0227       field = find(img.fwd_model.coarse2fine(:,field));
0228       field = field(1); <span class="comment">% they're all the same - by def of model_reduction</span>
0229       sigma = img.elem_data(field);
0230       E = E - sigma*invEi;
0231    <span class="keyword">end</span>
0232 
0233    <span class="comment">% Adjust the applied current and measurement matrices</span>
0234    pp.QQ = pp.QQ(m_idx,:);
0235    pp.VV = pp.VV(m_idx,:);
0236    pp.N2E= pp.N2E(:,m_idx);
0237    pp.mr_mapper = cumsum(m_idx); <span class="comment">%must be logical</span>
0238    pp.gnd_node = pp.mr_mapper(pp.gnd_node);
0239    <span class="keyword">if</span> pp.gnd_node==0
0240       error(<span class="string">'model_reduction removes ground node'</span>);
0241    <span class="keyword">end</span>
0242    
0243         
0244 <a name="_sub6" href="#_subfunctions" class="code">function unit_test_voltage_stims;</a>
0245    stim = zeros(16,1); volt=stim; stim([1,4]) = NaN; volt([1,4]) = [1,2];
0246    stimulv.stim_pattern = stim;
0247    stimulv.volt_pattern = volt;
0248    stimulv.meas_pattern = [1,0,0,-1,zeros(1,12)];
0249 
0250    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,16),1);
0251    img.fwd_model.stimulation = stimulv;
0252    img.fwd_solve.get_all_nodes = 1;
0253    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0254    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 Vstim #1'</span>, vh.meas, diff(volt(1:2,1)), 1e-14);
0255    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 Vstim #2'</span>, vh.volt(27+[1,4],1), volt([1,4]), 1e-14);
0256    tst = [ <span class="keyword">...</span>
0257    1.503131926779798; 1.412534629974291; 1.529078332819747;
0258    1.354399248512161; 1.546241676995996];
0259    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 Vstim #3'</span>, vh.volt(1:5:25,1), tst, 1e-14);
0260 
0261    img.fwd_model.stimulation(2) = stimulv;
0262    img.fwd_model.stimulation(1).stim_pattern([1,4]) = 0;
0263    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0264    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2c2 Vstim #4'</span>, vh.volt(1:5:25,2), tst, 1e-14);
0265 
0266    imgn = rmfield(img,<span class="string">'elem_data'</span>); imgn.node_data = vh.volt;
0267    imgn.calc_colours.clim = 1; subplot(221); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgn,1);
0268 
0269    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2C2'</span>,16),1);
0270    img.fwd_model.stimulation = stimulv;
0271    img.fwd_solve.get_all_nodes = 1;
0272    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0273    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #1'</span>, vh.meas, diff(volt(1:2)), 1e-14);
0274    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #2'</span>, vh.volt(<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img)+[1,4]), volt([1,4]), 1e-14);
0275    tst = [ <span class="keyword">...</span>
0276    1.499999999999998; 1.302478674263331; 1.609665333411830; <span class="keyword">...</span>
0277    1.215039511028270; 1.691145536046686];
0278    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #3'</span>, vh.volt(1:5:25), tst, 1e-13);
0279 
0280    imgn = rmfield(img,<span class="string">'elem_data'</span>); imgn.node_data = vh.volt(1:<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img));
0281    imgn.calc_colours.clim = 1; subplot(222); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgn,1);
0282 
0283    stim = zeros(16,1); volt=stim; stim([1,4]) = NaN; stim(8)=1; volt([1,4]) = [1,1];
0284    img.fwd_model.stimulation(2).stim_pattern = stim;
0285    img.fwd_model.stimulation(2).volt_pattern = volt;
0286    img.fwd_model.stimulation(2).meas_pattern = [1,-1,zeros(1,14)];
0287    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0288    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #4'</span>, vh.volt(<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img)+[1,4],1), [1;2], 1e-14);
0289    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #5'</span>, vh.volt(1:5:25,1), tst, 1e-13);
0290    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #6'</span>, vh.volt(<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img)+[1,4],2), [1;1], 1e-14);
0291    tst = [ 1.029942389400905; 1.024198991581187; <span class="keyword">...</span>
0292            1.048244746016660; 1.006551737030278; 1.057453501332724];
0293    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #7'</span>, vh.volt(1:5:25,2), tst, 1e-13); <span class="comment">% needs weaker tolerance</span>
0294 
0295    imgn = rmfield(img,<span class="string">'elem_data'</span>); imgn.node_data = vh.volt(1:<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img),2);
0296    subplot(223); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgn,1);
0297 
0298    stim = zeros(16,1); volt=stim; stim([3,6]) = NaN;  volt([3,6]) = [1,2];
0299    img.fwd_model.stimulation(3).stim_pattern = stim;
0300    img.fwd_model.stimulation(3).volt_pattern = volt;
0301    img.fwd_model.stimulation(3).meas_pattern = [1,-1,zeros(1,14)];
0302    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0303 
0304    imgn = rmfield(img,<span class="string">'elem_data'</span>); imgn.node_data = vh.volt(1:<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img),3);
0305    imgn.calc_colours.clim = 1; subplot(224); <a href="../../../eidors/graphics/matlab/show_fem.html" class="code" title="function hh=show_fem( mdl, options)">show_fem</a>(imgn,1);
0306 
0307    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'a2C2 Vstim #7'</span>, vh.volt(<a href="../../../eidors/models/num_nodes.html" class="code" title="function num = num_nodes( mdl );">num_nodes</a>(img)+[3,6],3), [1;2], 1e-14);
0308 
0309 
0310 
0311 <a name="_sub7" href="#_subfunctions" class="code">function do_unit_test</a>
0312    unit_test_voltage_stims;
0313 
0314 
0315    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b2c2'</span>,16),1);
0316    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0317    tst = [ <span class="keyword">...</span>
0318     0.959567140078593; 0.422175237237900; 0.252450963869202; <span class="keyword">...</span>
0319     0.180376116490602; 0.143799778367518];
0320    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'b2c2 TEST'</span>, vh.meas(1:5), tst, 1e-12);
0321 
0322    img.fwd_model = rmfield(img.fwd_model,<span class="string">'gnd_node'</span>);
0323    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0324    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'b2c2 gnd_node'</span>, vh.meas(1:5), tst, 1e-12);
0325 
0326    img.fwd_solve.get_elec_curr = 1;
0327    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0328    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( img.fwd_model); EC = pp.N2E*pp.QQ;
0329    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'b2b2 (CEM) elec_curr'</span>, vh.elec_curr, EC, 1e-11);
0330 
0331    img.fwd_solve.get_all_meas = 1;
0332    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0333     plot(vh.volt);
0334 
0335    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b2C2'</span>,16),1);
0336    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0337    tst = [ 0.385629619754662; 0.235061644846908; 0.172837756982388
0338            0.142197580506776; 0.126808900182258; 0.120605655110661];
0339    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'b2C2 (CEM) TEST'</span>, vh.meas(15:20), tst, 1e-12);
0340 
0341    img.fwd_solve.get_elec_curr = 1;
0342    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0343    pp = <a href="fwd_model_parameters.html" class="code" title="function param = fwd_model_parameters( fwd_model, opt )">fwd_model_parameters</a>( img.fwd_model); EC = pp.N2E*pp.QQ;
0344    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'b2C2 (CEM) elec_curr'</span>, vh.elec_curr, EC, 1e-11);
0345 
0346    <span class="comment">% bad stim patterns (flow through ground node)</span>
0347    img.fwd_model.stimulation(1).stim_pattern(2) = 0;
0348    vh = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>(img);
0349    lastw = lastwarn;
0350    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'gnd_node warning'</span>, lastw, <span class="keyword">...</span>
0351     <span class="string">'current flowing through ground node. Check stimulation pattern'</span>);
0352 
0353 
0354    <span class="comment">%2D resistor</span>
0355    current = 4; measure=1;
0356    [R,img] = <a href="../../../eidors/tests/test_2d_resistor.html" class="code" title="function test_2d_resistor(opt)">test_2d_resistor</a>(current,measure);
0357    img.fwd_solve.get_all_nodes = 1;
0358    vs = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>( img);
0359    va= measure*current*sum(R); <span class="comment">% analytic</span>
0360    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D resistor test'</span>, va, vs.meas, 1e-12);
0361 
0362    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D R z_contact'</span>, <span class="keyword">...</span>
0363                  [diff(vs.volt([13,1])), diff(vs.volt([14,12]))], <span class="keyword">...</span>
0364                  R(2)/2*current*[1,-1], 1e-12);
0365    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D R voltages'</span>, vs.volt(1:3:10)-vs.volt(1), <span class="keyword">...</span>
0366                  R(1)*current*linspace(0,1,4)', 1e-12);
0367 
0368    [R,img] = <a href="#_sub9" class="code" title="subfunction [R,img] = test_2d_resistor_faces(current,measure)">test_2d_resistor_faces</a>(current,measure);
0369    vs = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>( img);
0370    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'2D resistor faces'</span>, va, vs.meas, 1e-12);
0371 
0372    <span class="comment">%3D resistor</span>
0373    [R,img] = <a href="../../../eidors/tests/test_3d_resistor.html" class="code" title="">test_3d_resistor</a>(current,measure);
0374    img.fwd_solve.get_all_nodes = 1;
0375    vs = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>( img);
0376    va= current*sum(R);
0377    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D resistor test'</span>, va, vs.meas, 1e-10);
0378    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D R voltages'</span>, vs.volt(1:12:72)-vs.volt(1), <span class="keyword">...</span>
0379                  R(1)*current*linspace(0,1,6)', 1e-10);
0380    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D R z_contact'</span>, <span class="keyword">...</span>
0381                  [diff(vs.volt([73,1])), diff(vs.volt([74,72]))], <span class="keyword">...</span>
0382                  R(2)/2*current*[1,-1], 1e-10);
0383 
0384    [R,img] = <a href="#_sub11" class="code" title="subfunction [R,img] = test_3d_resistor_faces(current,measure);;">test_3d_resistor_faces</a>(current,measure);
0385    vs = <a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>( img);
0386    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'3D resistor faces'</span>, va, vs.meas, 1e-10);
0387 
0388 
0389 <a name="_sub8" href="#_subfunctions" class="code">function [R,img] = test_2d_resistor(current,measure)</a>
0390    conduc=  .4 + 2*pi*j*10; <span class="comment">% conductivity in Ohm-meters</span>
0391    z_contact= .1; wid = 3; len = 12; 
0392 
0393    fmdl=<a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],linspace(0,wid,3), linspace(0,len,4));
0394    fmdl.electrode(1).nodes = find(fmdl.nodes(:,2) ==   0);
0395    fmdl.electrode(2).nodes = find(fmdl.nodes(:,2) == len);
0396    [fmdl.electrode(:).z_contact] = deal(z_contact);
0397    fmdl.stimulation = <a href="../../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>([1,2,1,2],2,current,measure);
0398    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,conduc);
0399 
0400    Block_R = len / wid / conduc;
0401    Contact_R = z_contact/wid;
0402    R = [Block_R, 2*Contact_R];
0403 
0404 <span class="comment">% define electrode using face rather than nodes</span>
0405 <a name="_sub9" href="#_subfunctions" class="code">function [R,img] = test_2d_resistor_faces(current,measure)</a>
0406    conduc=  .4 + 2*pi*j*10; <span class="comment">% conductivity in Ohm-meters</span>
0407    z_contact= .1; wid = 3; len = 12; 
0408 
0409    fmdl=<a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],linspace(0,wid,3), linspace(0,len,4));
0410    bdy = fmdl.boundary;
0411    bdy( any(reshape(fmdl.nodes(bdy,2),size(bdy))&gt;0,2),:)=[];
0412    fmdl.electrode(1).nodes = [];
0413    fmdl.electrode(1).faces = bdy;
0414    fmdl.electrode(2).nodes = find(fmdl.nodes(:,2) == len);
0415    [fmdl.electrode(:).z_contact] = deal(z_contact);
0416    fmdl.stimulation = <a href="../../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>([1,2,1,2],2,current,measure);
0417    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,conduc);
0418 
0419    Block_R = len / wid / conduc;
0420    Contact_R = z_contact/wid;
0421    R = [Block_R, 2*Contact_R];
0422 
0423 <a name="_sub10" href="#_subfunctions" class="code">function [R,img] = test_3d_resistor(current,measure);;</a>
0424    conduc=  .4 + 2*pi*j*10; <span class="comment">% conductivity in Ohm-meters</span>
0425    z_contact= .1; wid = 2; len = 5; hig=3; 
0426 
0427    fmdl=<a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],0:wid, 0:hig, 0:len);
0428    fmdl.electrode(1).nodes = find(fmdl.nodes(:,3) ==   0);
0429    fmdl.electrode(2).nodes = find(fmdl.nodes(:,3) == len);
0430    [fmdl.electrode(:).z_contact] = deal(z_contact);
0431    fmdl.stimulation = <a href="../../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>([1,2,1,2],2,current,measure);
0432    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,conduc);
0433 
0434    Block_R =  len / wid / hig / conduc;
0435    Contact_R = z_contact/(wid*hig);
0436    R = [Block_R, 2*Contact_R];
0437 
0438 <span class="comment">% define electrode using face rather than nodes</span>
0439 <a name="_sub11" href="#_subfunctions" class="code">function [R,img] = test_3d_resistor_faces(current,measure);;</a>
0440    conduc=  .4 + 2*pi*j*10; <span class="comment">% conductivity in Ohm-meters</span>
0441    z_contact= .1; wid = 2; len = 5; hig=3; 
0442 
0443    fmdl=<a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],0:wid, 0:hig, 0:len);
0444 <span class="comment">%  fmdl.electrode(1).nodes = find(fmdl.nodes(:,3) ==   0);</span>
0445    bdy = fmdl.boundary;
0446    bdy( any(reshape(fmdl.nodes(bdy,3),size(bdy))&gt;0,2),:)=[];
0447    fmdl.electrode(1).nodes = [];
0448    fmdl.electrode(1).faces = bdy;
0449    fmdl.electrode(2).nodes = find(fmdl.nodes(:,3) == len);
0450    [fmdl.electrode(:).z_contact] = deal(z_contact);
0451    fmdl.stimulation = <a href="../../../eidors/models/stim_meas_list.html" class="code" title="function [stim, meas_sel]= stim_meas_list( sp_mp , Nelec, current, gain);">stim_meas_list</a>([1,2,1,2],2,current,measure);
0452    img= <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(fmdl,conduc);
0453 
0454    Block_R =  len / wid / hig / conduc;
0455    Contact_R = z_contact/(wid*hig);
0456    R = [Block_R, 2*Contact_R];
0457 
0458 <a name="_sub12" href="#_subfunctions" class="code">function [R,img] = test_3d_resistor_old(current,measure);</a>
0459    ll=5*1; <span class="comment">% length</span>
0460    ww=1*2; <span class="comment">% width</span>
0461    hh=1*3; <span class="comment">% height</span>
0462    conduc= .13;  <span class="comment">% conductivity in Ohm-meters</span>
0463    z_contact= 1e-1;
0464    scale = .46;
0465    nn=0;
0466    <span class="keyword">for</span> z=0:ll; <span class="keyword">for</span> x=0:ww; <span class="keyword">for</span> y=0:hh
0467       nn=nn+1;
0468       mdl.nodes(nn,:) = [x,y,z];
0469    <span class="keyword">end</span>; <span class="keyword">end</span>; <span class="keyword">end</span>
0470    mdl= <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'fwd_model'</span>,<span class="string">'3D rectangle'</span>);
0471    mdl= <a href="../../../eidors/models/mk_grid_model.html" class="code" title="function [cmdl, c2f]= mk_grid_model(fmdl, xvec, yvec, zvec);">mk_grid_model</a>([],0:ww,0:hh,0:ll);
0472    mdl.nodes= mdl.nodes*scale;
0473    mdl= rmfield(mdl,<span class="string">'coarse2fine'</span>);
0474 
0475    mdl.boundary= <a href="find_boundary.html" class="code" title="function [srf, idx] = find_boundary(simp);">find_boundary</a>(mdl.elems);
0476    mdl.gnd_node = 1;
0477    elec_nodes= [1:(ww+1)*(hh+1)];
0478    elec(1).nodes= elec_nodes;      elec(1).z_contact= z_contact;
0479    elec(2).nodes= nn-elec_nodes+1; elec(2).z_contact= z_contact;
0480    stim.stim_pattern= [-1;1]*current;
0481    stim.meas_pattern= [-1,1]*measure;
0482    mdl.stimulation= stim;
0483    mdl.electrode= elec;
0484    mdl = <a href="../../../eidors/models/mdl_normalize.html" class="code" title="function out = mdl_normalize(mdl, val)">mdl_normalize</a>(mdl,0);
0485 
0486    mdl.solve = @<a href="fwd_solve_1st_order.html" class="code" title="function data =fwd_solve_1st_order(fwd_model, img)">fwd_solve_1st_order</a>;
0487    mdl.system_mat = @<a href="system_mat_1st_order.html" class="code" title="function s_mat= system_mat_1st_order( fwd_model, img)">system_mat_1st_order</a>;
0488    img= <a href="../../../eidors/eidors_obj.html" class="code" title="function [obj_id, extra_out] = eidors_obj(type,name, varargin )">eidors_obj</a>(<span class="string">'image'</span>,<span class="string">'3D rectangle'</span>, <span class="keyword">...</span>
0489          <span class="string">'elem_data'</span>, ones(size(mdl.elems,1),1) * conduc, <span class="keyword">...</span>
0490          <span class="string">'fwd_model'</span>, mdl); 
0491 
0492    <span class="comment">% analytical solution</span>
0493    Block_R =  ll / ww / hh / scale/ conduc;
0494    Contact_R = z_contact/(ww*hh)/scale^2;
0495    <span class="comment">% Contact R reflects z_contact / (width/scale)^2. Here we need to use</span>
0496    <span class="comment">%  the scale, since this is not reflected in the size of the</span>
0497    <span class="comment">%  FEM as created by the grid. This is different to the test_2d_resistor,</span>
0498    <span class="comment">%  where the FEM is created scaled, so that the ww</span>
0499    <span class="comment">%  don't need to be scaled by the scale parameter.</span>
0500    R =[ Block_R , 2*Contact_R];</pre></div>
<hr><address>Generated on Tue 31-Dec-2019 17:38:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>