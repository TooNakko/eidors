<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of calc_slices</title>
  <meta name="keywords" content="calc_slices">
  <meta name="description" content="calc_slices (img, levels, clim  ) show slices at levels of an">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="../../index.html">eidors</a> &gt; <a href="#">graphics</a> &gt; <a href="index.html">matlab</a> &gt; calc_slices.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for eidors/graphics/matlab&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>calc_slices
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>calc_slices (img, levels, clim  ) show slices at levels of an</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function rimg = calc_slices( img, levels ); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> calc_slices (img, levels, clim  ) show slices at levels of an
             using a fast rendering algorithm
 img    = EIDORS image struct, or array of I images
 levels = Matrix [Lx3] of L image levels
          each row of the matrix specifies the intercepts
          of the slice on the x, y, z axis. To specify a z=2 plane
          parallel to the x,y: use levels= [inf,inf,2]

 if levels is scalar, then make levels equispaced horizontal
          cuts through the object

 PARAMETERS:
   img.calc_slices.filter % Filter to be applied to images
      Example:    img.calc_slices.filter = ones(3)/9
   img.calc_slices.scale  % Scaling to apply to images
   img.calc_slices.levels % an alternative way to specify levels
   img.get_img_data.frame_select = which frames of image to display

 rimg= np x np x I x L where np is 128 by default

   np can be adjusted by calc_colours('npoints')
     or by setting
   img.fwd_model.mdl_slice_mapper.{npx, npy}
        see help of mdl_slice_mapper for more options</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>	EIDORS_MSG eidors progress and status messages</li><li><a href="calc_colours.html" class="code" title="function [colours,scl_data]= calc_colours(img, set_value, do_colourbar)">calc_colours</a>	[colours,scl_data]= calc_colours(img, set_value, do_colourbar)</li><li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>	MDL_SLICE_MAPPER: map pixels to FEM elements or nodes</li><li><a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>	DATA_MAPPER maps img.params data to elem or node data</li><li><a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>	MDL_DIM: dimension of model space (are nodes in 2D or 3D space)</li><li><a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>	MK_COMMON_MODEL: make common EIT models</li><li><a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>	MK_IMAGE: create eidors image object</li><li><a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>	CALC_JACOBIAN_BKGND: calculate background image around</li><li><a href="../../../eidors/solvers/get_img_data.html" class="code" title="function [img_data, n_images]= get_img_data(img)">get_img_data</a>	GET_IMG_DATA: get parameter data from eidors image object</li><li><a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>	UNIT_TEST_CMP: compare matrices in eidors output</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../eidors/algorithms/calc_posn_resolution.html" class="code" title="function [br,pos]= calc_posn_resolution( img, fwd_model)">calc_posn_resolution</a>	CALC_POSN_RESOLUTION: calculate posn and resolution of a target</li><li><a href="../../../eidors/algorithms/eval_GREIT_fig_merit.html" class="code" title="function params = eval_GREIT_fig_merit(imgs, xyzr_pt)">eval_GREIT_fig_merit</a>	EVAL_GREIT_FIG_MERIT: calculate GREIT figures of merit for images</li><li><a href="animate_reconstructions.html" class="code" title="function fname_out= animate_reconstructions(fname, imgs);">animate_reconstructions</a>	animate_reconstructions(fname, imgs);</li><li><a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>	calc_slices (img, levels, clim  ) show slices at levels of an</li><li><a href="show_slices.html" class="code" title="function out_img= show_slices( img, levels )">show_slices</a>	out_img = show_slices (img, levels ) show slices at levels of an</li><li><a href="../../../eidors/interface/eidors_saveimg.html" class="code" title="function eidors_saveimg( img, fname, format, pp )">eidors_saveimg</a>	EIDORS saveimg - save reconstructed image files in formats</li><li><a href="../../../eidors/interface/igt2img.html" class="code" title="function img = igt2img(igt)">igt2img</a>	IGT2IMG constructs an EIDORS IMG struct from an IGT frames-by-912 matrix.</li><li><a href="../../../eidors/interface/img2igt.html" class="code" title="function igt = img2igt(img)">img2igt</a>	IMG2IGT returns an IGT-compatible image matrix from any EIDORS</li><li><a href="../../../eidors/interface/sigmatome2_filter.html" class="code" title="function [Filter, stim_pattern]= sigmatome2_filter(test);">sigmatome2_filter</a>	SIGMATOME2_FILTER:  Hardware filter and stim_patterns for Sigmatome II device</li><li><a href="../../../eidors/models/mk_pixel_slice.html" class="code" title="function [imdl fmdl] = mk_pixel_slice(imdl,level,opt)">mk_pixel_slice</a>	MK_PIXEL_SLICE create a pixel model to reconstruct on</li><li><a href="../../../eidors/models/solve_RM_2Dslice.html" class="code" title="function imdl = solve_RM_2Dslice(imdl, sel_fcn)">solve_RM_2Dslice</a>	SOLVE_RM_2DSLICE: cut slices out of a 3D model</li><li><a href="../../../eidors/solvers/inverse/calc_image_SNR.html" class="code" title="function [SNRmean, SE, debug] = calc_image_SNR(imdl, hyperparameter, doPlot)">calc_image_SNR</a>	% CALC_IMAGE_SNR: Calculates the signal-to-noise ratio (SNR) in the image</li><li><a href="../../../eidors/tests/test_colour_direction.html" class="code" title="">test_colour_direction</a>	Test colour mapping</li><li><a href="../../../eidors/tools/test_performance.html" class="code" title="function [r, params] =  test_performance( imdls, fmdl );">test_performance</a>	TEST_PERFORMANCE: test of difference reconstruction algorithms</li><li><a href="../../../eidors/tools/test_performance_img.html" class="code" title="function [params_img] =  test_performance_img( imdls, fmdl );">test_performance_img</a>	TEST_PERFORMANCE: test of difference reconstruction algorithms</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function rimg = calc_this_slice( img, levels, np)</a></li><li><a href="#_sub2" class="code">function rimg= calc_image_nearestnodes( node_data, level, fwd_model, np);</a></li><li><a href="#_sub3" class="code">function rimg= calc_image_nodes( node_data, level, fwd_model, np)</a></li><li><a href="#_sub4" class="code">function rimg= calc_image_elems( elem_data, level, fwd_model, np)</a></li><li><a href="#_sub5" class="code">function  rimg = filter_image(rimg, filt);</a></li><li><a href="#_sub6" class="code">function do_unit_test</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function rimg = calc_slices( img, levels );</a>
0002 <span class="comment">% calc_slices (img, levels, clim  ) show slices at levels of an</span>
0003 <span class="comment">%             using a fast rendering algorithm</span>
0004 <span class="comment">% img    = EIDORS image struct, or array of I images</span>
0005 <span class="comment">% levels = Matrix [Lx3] of L image levels</span>
0006 <span class="comment">%          each row of the matrix specifies the intercepts</span>
0007 <span class="comment">%          of the slice on the x, y, z axis. To specify a z=2 plane</span>
0008 <span class="comment">%          parallel to the x,y: use levels= [inf,inf,2]</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% if levels is scalar, then make levels equispaced horizontal</span>
0011 <span class="comment">%          cuts through the object</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% PARAMETERS:</span>
0014 <span class="comment">%   img.calc_slices.filter % Filter to be applied to images</span>
0015 <span class="comment">%      Example:    img.calc_slices.filter = ones(3)/9</span>
0016 <span class="comment">%   img.calc_slices.scale  % Scaling to apply to images</span>
0017 <span class="comment">%   img.calc_slices.levels % an alternative way to specify levels</span>
0018 <span class="comment">%   img.get_img_data.frame_select = which frames of image to display</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% rimg= np x np x I x L where np is 128 by default</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%   np can be adjusted by calc_colours('npoints')</span>
0023 <span class="comment">%     or by setting</span>
0024 <span class="comment">%   img.fwd_model.mdl_slice_mapper.{npx, npy}</span>
0025 <span class="comment">%        see help of mdl_slice_mapper for more options</span>
0026 <span class="comment">%</span>
0027 
0028 <span class="comment">% (C) 2006 Andy Adler. License: GPL version 2 or version 3</span>
0029 <span class="comment">% $Id: calc_slices.m 6010 2019-06-29 19:42:01Z aadler $</span>
0030 
0031 <span class="keyword">if</span> ischar(img) &amp;&amp; strcmp(img,<span class="string">'UNIT_TEST'</span>); <a href="#_sub6" class="code" title="subfunction do_unit_test">do_unit_test</a>; <span class="keyword">return</span>; <span class="keyword">end</span>
0032 
0033 np = <a href="calc_colours.html" class="code" title="function [colours,scl_data]= calc_colours(img, set_value, do_colourbar)">calc_colours</a>(<span class="string">'npoints'</span>);
0034 <span class="keyword">try</span>   np = img(1).calc_colours.npoints;
0035 <span class="keyword">end</span>
0036 
0037 <span class="keyword">if</span> nargin &lt; 2
0038     <span class="keyword">try</span> 
0039         levels = img.calc_slices.levels; 
0040     <span class="keyword">catch</span>
0041         levels = [];
0042     <span class="keyword">end</span>
0043 <span class="keyword">end</span>
0044 
0045 img = <a href="../../../eidors/models/data_mapper.html" class="code" title="function img = data_mapper(img, reverse)">data_mapper</a>(img);
0046 
0047 <span class="comment">% Assume all fwd_models are same dimension (all 3D or 2D no mixed dims)</span>
0048 <span class="keyword">if</span> <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(img(1))==2 
0049    <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(levels);
0050        <span class="keyword">if</span> ~all(levels(1,:) == [inf,inf,0])
0051           warning(<span class="string">'specified levels ignored for 2D FEM'</span>);
0052        <span class="keyword">end</span>
0053    <span class="keyword">end</span>
0054    levels= [Inf,Inf,0];
0055 <span class="keyword">elseif</span> <a href="../../../eidors/models/mdl_dim.html" class="code" title="function num = mdl_dim( mdl );">mdl_dim</a>(img(1))==3 &amp;&amp; isempty(levels)
0056    levels = [Inf Inf mean(img.fwd_model.nodes(:,3))];
0057    <a href="../../../eidors/eidors_msg.html" class="code" title="function log_level= eidors_msg( message, varargin )">eidors_msg</a>(<span class="string">'calc_slices: no levels specified, assuming an xy plane'</span>,2);
0058 <span class="keyword">end</span>
0059 
0060 
0061 rimg = [];
0062 <span class="keyword">for</span> i=1:length(img)
0063    rimg = cat(3, rimg, <a href="#_sub1" class="code" title="subfunction rimg = calc_this_slice( img, levels, np)">calc_this_slice</a>( img(i), levels, np) );
0064 <span class="keyword">end</span>
0065 
0066 <a name="_sub1" href="#_subfunctions" class="code">function rimg = calc_this_slice( img, levels, np)</a>
0067     <span class="comment">% If scalar levels then we just create that many cut planes on z-dimension</span>
0068     fwd_model = img.fwd_model;
0069     <span class="keyword">if</span> size(levels)== [1,1]
0070        zmax= max(fwd_model.nodes(:,3));
0071        zmin= min(fwd_model.nodes(:,3));
0072        levels = linspace(zmin,zmax, levels+2);
0073        levels = levels(2:end-1)'*[Inf,Inf,1];
0074     <span class="keyword">end</span>
0075     num_levs= size(levels,1);
0076     <span class="keyword">if</span> isfield(img,<span class="string">'elem_data'</span>)
0077        [elem_data, n_images] = <a href="../../../eidors/solvers/get_img_data.html" class="code" title="function [img_data, n_images]= get_img_data(img)">get_img_data</a>(img);
0078 
0079        clear rimg;
0080        <span class="keyword">for</span> lev_no = fliplr(1:num_levs)
0081            <span class="comment">% start at max so memory is allocated once</span>
0082           level= levels( lev_no, 1:3 );
0083           rimg(:,:,:,lev_no) = <a href="#_sub4" class="code" title="subfunction rimg= calc_image_elems( elem_data, level, fwd_model, np)">calc_image_elems</a>( elem_data, level, fwd_model, np);
0084        <span class="keyword">end</span>
0085     <span class="keyword">elseif</span> isfield(img,<span class="string">'node_data'</span>)
0086        [node_data, n_images] = <a href="../../../eidors/solvers/get_img_data.html" class="code" title="function [img_data, n_images]= get_img_data(img)">get_img_data</a>(img);
0087 <span class="comment">%      node_data= [img.node_data];</span>
0088 <span class="comment">%      if size(node_data,1)==1; node_data=node_data';end</span>
0089 <span class="comment">%      n_images= size(node_data,2);</span>
0090        clear rimg;
0091 
0092        <span class="keyword">for</span> lev_no = fliplr(1:num_levs)
0093           level= levels( lev_no, 1:3 );
0094           rimg(:,:,:,lev_no) = <span class="keyword">...</span>
0095              <a href="#_sub3" class="code" title="subfunction rimg= calc_image_nodes( node_data, level, fwd_model, np)">calc_image_nodes</a>( node_data, level, fwd_model, np);
0096        <span class="keyword">end</span>
0097     <span class="keyword">else</span>
0098        error(<span class="string">'img does not have a data field'</span>);
0099     <span class="keyword">end</span>
0100 
0101     <span class="comment">% FILTER IMAGE</span>
0102     <span class="keyword">try</span>   
0103         filt = img.calc_slices.filter; 
0104     <span class="keyword">catch</span>
0105         filt = 1; 
0106     <span class="keyword">end</span>
0107     <span class="keyword">try</span>   
0108         scal = img.calc_slices.scale; 
0109     <span class="keyword">catch</span>
0110         scal = 1; 
0111     <span class="keyword">end</span>
0112 
0113     filt = scal * ( filt/sum(filt(:)) );
0114     rimg = <a href="#_sub5" class="code" title="subfunction  rimg = filter_image(rimg, filt);">filter_image</a>(rimg, filt);
0115 
0116 <span class="comment">% Calculate an image by mapping it onto the node_ptr matrix</span>
0117 <span class="comment">% This makes a blocky image to nearest node -&gt; no longer used</span>
0118 <a name="_sub2" href="#_subfunctions" class="code">function rimg= calc_image_nearestnodes( node_data, level, fwd_model, np);</a>
0119    <span class="keyword">if</span> ~isfield(fwd_model,<span class="string">'mdl_slice_mapper'</span>);
0120       fwd_model.mdl_slice_mapper.npx  = np;
0121       fwd_model.mdl_slice_mapper.npy  = np;
0122       fwd_model.mdl_slice_mapper.level= level;
0123    <span class="keyword">end</span>
0124    node_ptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>( fwd_model, <span class="string">'node'</span> );
0125 
0126    backgnd= NaN;
0127    n_images= size(node_data,2);
0128    rval= [backgnd*ones(1,n_images); node_data];
0129    rimg= reshape( rval(node_ptr+1,:), [size(node_ptr), n_images]);
0130 
0131 <span class="comment">% Calculate an image by interpolating it onto the elem_ptr matrix</span>
0132 <a name="_sub3" href="#_subfunctions" class="code">function rimg= calc_image_nodes( node_data, level, fwd_model, np)</a>
0133 
0134    <span class="keyword">if</span> ~isfield(fwd_model,<span class="string">'mdl_slice_mapper'</span>);
0135       fwd_model.mdl_slice_mapper.npx  = np;
0136       fwd_model.mdl_slice_mapper.npy  = np;
0137       fwd_model.mdl_slice_mapper.level= level;
0138    <span class="keyword">end</span>
0139 
0140    nd_interp= <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>( fwd_model, <span class="string">'nodeinterp'</span> );
0141    elem_ptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>( fwd_model, <span class="string">'elem'</span> );
0142    [sx,sy]= size(elem_ptr);
0143 
0144    node_ptr = fwd_model.elems; node_ptr = [0*node_ptr(1,:);node_ptr];
0145    node_ptr = reshape( node_ptr( elem_ptr+1, :), sx, sy, []);
0146 
0147    n_images = size(node_data,2);
0148    rimg= zeros(sx, sy, n_images);
0149    backgnd= NaN;
0150    
0151    <span class="keyword">for</span> ni = 1:n_images
0152      znd = [backgnd;node_data(:,ni)]; <span class="comment">% add NaN for background</span>
0153      rimg(:,:,ni) = sum( znd(node_ptr+1) .* nd_interp, 3); 
0154    <span class="keyword">end</span>
0155 
0156 
0157 <span class="comment">% Calculate an image by mapping it onto the elem_ptr matrix</span>
0158 <a name="_sub4" href="#_subfunctions" class="code">function rimg= calc_image_elems( elem_data, level, fwd_model, np)</a>
0159 
0160    <span class="keyword">if</span> ~isfield(fwd_model,<span class="string">'mdl_slice_mapper'</span>);
0161       fwd_model.mdl_slice_mapper.npx  = np;
0162       fwd_model.mdl_slice_mapper.npy  = np;
0163       fwd_model.mdl_slice_mapper.level= level;
0164       <span class="comment">% grid model sets mdl_slice_mapper.np* but not level</span>
0165    <span class="keyword">elseif</span> ~isfield(fwd_model.mdl_slice_mapper,<span class="string">'level'</span>);
0166       fwd_model.mdl_slice_mapper.level= level;
0167    <span class="keyword">end</span>
0168    elem_ptr = <a href="mdl_slice_mapper.html" class="code" title="function map = mdl_slice_mapper( fmdl, maptype );">mdl_slice_mapper</a>( fwd_model, <span class="string">'elem'</span> );
0169 
0170    backgnd= NaN;
0171    n_images= size(elem_data,2);
0172    rval= backgnd*ones(size(elem_data)+[1,0]);
0173    rval(2:<span class="keyword">end</span>,:) = elem_data;
0174    rimg= reshape( rval(elem_ptr+1,:), [size(elem_ptr), n_images]);
0175 
0176 
0177 <a name="_sub5" href="#_subfunctions" class="code">function  rimg = filter_image(rimg, filt);</a>
0178     
0179    <span class="comment">%%% Total MATLAB BS )(*&amp;#$)(*#&amp;@</span>
0180    <span class="comment">%%% the &amp;&amp; operator used to short circuit. Now it doesn't</span>
0181    <span class="comment">%%% How the (*&amp;)(*&amp; can anyone take this language seriously</span>
0182    <span class="comment">% all(size(filt*scal) == [1,1]) &amp;&amp; filt*scal == 1</span>
0183    <span class="keyword">if</span> all(size(filt)==1) <span class="keyword">if</span> filt == 1; <span class="keyword">return</span>; <span class="keyword">end</span> ; <span class="keyword">end</span>
0184 
0185    [sz1,sz2,sz3,sz4] = size(rimg);
0186    <span class="keyword">for</span> j1 = 1:sz3; <span class="keyword">for</span> j2 = 1:sz4; 
0187       rsl = rimg(:,:,j1,j2);
0188 
0189       rna = isnan(rsl);
0190       rsl(rna) = 0;
0191       rsl = conv2(rsl, filt, <span class="string">'same'</span>);
0192       rsl(rna) = NaN;
0193 
0194       rimg(:,:,j1,j2) = rsl;
0195    <span class="keyword">end</span>; <span class="keyword">end</span>
0196 
0197 <a name="_sub6" href="#_subfunctions" class="code">function do_unit_test</a>
0198    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8));
0199    img.calc_colours.npoints = 8; 
0200 
0201    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0202    imt = NaN*ones(8); imt(3:6,2:7) = 1; imt(2:7,3:6) = 1; 
0203    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 1'</span>, imc, imt);
0204 
0205    imn = rmfield(img,<span class="string">'elem_data'</span>);
0206    imn.node_data = ones(size(imn.fwd_model.nodes,1),1);
0207    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(imn);
0208    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 2'</span>, imc, imt, 1e-14);
0209 
0210    img.elem_data(1:4) = 2;
0211    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0212    imt(3:6,3:6) = 1; imt(4:5,4:5) = 2; 
0213    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 3'</span>, imc, imt);
0214 
0215    imn.node_data(1:5) = 2;
0216    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(imn);
0217    imt(3:6,3:6) = 1; imt(4:5,3:6) = 1.049020821501088;
0218    imt(3:6,4:5) = 1.049020821501088; imt(4:5,4:5) = 2;
0219    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 4'</span>, imc, imt, 1e-14);
0220 
0221    imn.node_data(:) = 1; imn.node_data(1) = 4;
0222    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(imn);
0223    imt(3:6,3:6) = 1; imt(4:5,4:5) = 1.575633893074693; 
0224    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 5'</span>, imc, imt, 1e-14);
0225 
0226    imn.calc_colours.npoints = 7; 
0227    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(imn);
0228 <span class="comment">% FIXME: the region is offset left for odd npoints</span>
0229    imt = NaN*ones(7); imt(2:6,2:6) = 1; imt(4,1:7)= 1; imt(1:7,4)= 1;imt(4,4) = 4; 
0230    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 2d 6'</span>, imc, imt, 1e-14);
0231 
0232 
0233 <span class="comment">% 3D Tests</span>
0234    img = <a href="../../../eidors/solvers/calc_jacobian_bkgnd.html" class="code" title="function img_bkgnd = calc_jacobian_bkgnd( inv_model )">calc_jacobian_bkgnd</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'n3r2'</span>,[16,2]));
0235    img.calc_colours.npoints = 8; 
0236    imn = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img,[inf,inf,1]);
0237 
0238    imt = NaN*ones(8); imt(3:6,2:7) = 1; imt(2:7,3:6) = 1; 
0239    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 3d 1'</span>, imn, imt);
0240 
0241    imn = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img,[inf,0,inf]);
0242    imt = NaN*ones(8); imt(1:8,3:6) = 1; 
0243    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 3d 2'</span>, imn, imt);
0244 
0245    <span class="comment">% Should have no effect</span>
0246    img.fwd_model.nodes(:,3) = img.fwd_model.nodes(:,3)-1;
0247    imn = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img,[inf,0,inf]); 
0248    imt = NaN*ones(8); imt(1:8,3:6) = 1; 
0249    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs 3d 3'</span>, imn, imt);
0250 
0251 
0252 <span class="comment">% multi image struct</span>
0253    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'a2c2'</span>,8));
0254    img.calc_colours.npoints = 8; 
0255    img(2) = img;
0256    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img); 
0257    imt = NaN*ones(8); imt(3:6,2:7) = 1; imt(2:7,3:6) = 1; 
0258    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs mult 1'</span>, imc, cat(3,imt,imt));
0259 
0260    imgb = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>( <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'b2c2'</span>,8));
0261    imgb.calc_colours.npoints = 8; 
0262    img(3)=imgb;
0263    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img); 
0264    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'cs mult 2'</span>, imc, cat(3,imt,imt,imt));
0265 
0266    imdl = <a href="../../../eidors/models/mk_common_model.html" class="code" title="function inv_mdl= mk_common_model( str, n_elec, varargin )">mk_common_model</a>(<span class="string">'c2t2'</span>,16);
0267    img = <a href="../../../eidors/models/mk_image.html" class="code" title="function img= mk_image(mdl, elem_data, params, name)">mk_image</a>(imdl,1);
0268    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0269    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size e  1'</span>, size(imc), [64,64]);
0270 
0271    img.calc_colours.npoints = 40;
0272    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0273    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size e  2'</span>, size(imc), [40,40]);
0274 
0275    img.fwd_model.mdl_slice_mapper.npx = 22;
0276    img.fwd_model.mdl_slice_mapper.npy = 32;
0277    img.fwd_model.mdl_slice_mapper.level = [inf,inf,0];
0278    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0279    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size e  3'</span>, size(imc), [32,22]);
0280 
0281    img.fwd_model = rmfield(img.fwd_model,<span class="string">'mdl_slice_mapper'</span>);
0282    img.fwd_model.mdl_slice_mapper.x_pts = linspace(-150,150,20);
0283    img.fwd_model.mdl_slice_mapper.y_pts =-linspace(-150,150,23);
0284    img.fwd_model.mdl_slice_mapper.level = [inf,inf,0];
0285    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0286    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size e  4'</span>, size(imc), [23,20]);
0287 
0288    img = rmfield(img,<span class="string">'elem_data'</span>);
0289    img.node_data =  ones(size(img.fwd_model.nodes,1),1);
0290    img.node_data =  (1:size(img.fwd_model.nodes,1))';
0291    img.fwd_model = rmfield(img.fwd_model,<span class="string">'mdl_slice_mapper'</span>);
0292    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0293    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size n  1'</span>, size(imc), [40,40]);
0294 
0295    im2= img;
0296    im2.node_data =  ones(size(img.fwd_model.nodes,1),5);
0297    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(im2);
0298    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size n x5'</span>, size(imc), [40,40,5]);
0299    im2.get_img_data.frame_select = 2:3;
0300    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(im2);
0301    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size n x2'</span>, size(imc), [40,40,2]);
0302 
0303    img.fwd_model.mdl_slice_mapper.x_pts = linspace(-150,150,20);
0304    img.fwd_model.mdl_slice_mapper.y_pts =-linspace(-150,150,23);
0305    img.fwd_model.mdl_slice_mapper.level = [inf,inf,0];
0306    imc = <a href="calc_slices.html" class="code" title="function rimg = calc_slices( img, levels );">calc_slices</a>(img);
0307    <a href="../../../eidors/tools/unit_test_cmp.html" class="code" title="function unit_test_cmp(txt,a,b,tol)">unit_test_cmp</a>(<span class="string">'size n  2'</span>, size(imc), [23,20]);</pre></div>
<hr><address>Generated on Tue 31-Dec-2019 17:38:21 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>